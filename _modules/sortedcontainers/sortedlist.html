
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sortedcontainers.sortedlist &#8212; pyStim 1.1 documentation</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pyStim 1.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">sortedcontainers.sortedlist</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sortedcontainers.sortedlist</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Sorted List</span>
<span class="sd">==============</span>

<span class="sd">:doc:`Sorted Containers&lt;index&gt;` is an Apache2 licensed Python sorted</span>
<span class="sd">collections library, written in pure-Python, and fast as C-extensions. The</span>
<span class="sd">:doc:`introduction&lt;introduction&gt;` is the best way to get started.</span>

<span class="sd">Sorted list implementations:</span>

<span class="sd">.. currentmodule:: sortedcontainers</span>

<span class="sd">* :class:`SortedList`</span>
<span class="sd">* :class:`SortedKeyList`</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># pylint: disable=too-many-lines</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">traceback</span>

<span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">bisect_left</span><span class="p">,</span> <span class="n">bisect_right</span><span class="p">,</span> <span class="n">insort</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">repeat</span><span class="p">,</span> <span class="n">starmap</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">add</span><span class="p">,</span> <span class="n">eq</span><span class="p">,</span> <span class="n">ne</span><span class="p">,</span> <span class="n">gt</span><span class="p">,</span> <span class="n">ge</span><span class="p">,</span> <span class="n">lt</span><span class="p">,</span> <span class="n">le</span><span class="p">,</span> <span class="n">iadd</span>
<span class="kn">from</span> <span class="nn">textwrap</span> <span class="kn">import</span> <span class="n">dedent</span>

<span class="c1">###############################################################################</span>
<span class="c1"># BEGIN Python 2/3 Shims</span>
<span class="c1">###############################################################################</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">MutableSequence</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">MutableSequence</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">hexversion</span>

<span class="k">if</span> <span class="n">hexversion</span> <span class="o">&lt;</span> <span class="mh">0x03000000</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">imap</span> <span class="k">as</span> <span class="nb">map</span>  <span class="c1"># pylint: disable=redefined-builtin</span>
    <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">izip</span> <span class="k">as</span> <span class="nb">zip</span>  <span class="c1"># pylint: disable=redefined-builtin</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">thread</span> <span class="kn">import</span> <span class="n">get_ident</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">dummy_thread</span> <span class="kn">import</span> <span class="n">get_ident</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">_thread</span> <span class="kn">import</span> <span class="n">get_ident</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">_dummy_thread</span> <span class="kn">import</span> <span class="n">get_ident</span>


<span class="k">def</span> <span class="nf">recursive_repr</span><span class="p">(</span><span class="n">fillvalue</span><span class="o">=</span><span class="s1">&#39;...&#39;</span><span class="p">):</span>
    <span class="s2">&quot;Decorator to make a repr function return fillvalue for a recursive call.&quot;</span>
    <span class="c1"># pylint: disable=missing-docstring</span>
    <span class="c1"># Copied from reprlib in Python 3</span>
    <span class="c1"># https://hg.python.org/cpython/file/3.6/Lib/reprlib.py</span>

    <span class="k">def</span> <span class="nf">decorating_function</span><span class="p">(</span><span class="n">user_function</span><span class="p">):</span>
        <span class="n">repr_running</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="nd">@wraps</span><span class="p">(</span><span class="n">user_function</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">get_ident</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">repr_running</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fillvalue</span>
            <span class="n">repr_running</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">user_function</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">repr_running</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">return</span> <span class="n">wrapper</span>

    <span class="k">return</span> <span class="n">decorating_function</span>

<span class="c1">###############################################################################</span>
<span class="c1"># END Python 2/3 Shims</span>
<span class="c1">###############################################################################</span>


<span class="k">class</span> <span class="nc">SortedList</span><span class="p">(</span><span class="n">MutableSequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sorted list is a sorted mutable sequence.</span>

<span class="sd">    Sorted list values are maintained in sorted order.</span>

<span class="sd">    Sorted list values must be comparable. The total ordering of values must</span>
<span class="sd">    not change while they are stored in the sorted list.</span>

<span class="sd">    Methods for adding values:</span>

<span class="sd">    * :func:`SortedList.add`</span>
<span class="sd">    * :func:`SortedList.update`</span>
<span class="sd">    * :func:`SortedList.__add__`</span>
<span class="sd">    * :func:`SortedList.__iadd__`</span>
<span class="sd">    * :func:`SortedList.__mul__`</span>
<span class="sd">    * :func:`SortedList.__imul__`</span>

<span class="sd">    Methods for removing values:</span>

<span class="sd">    * :func:`SortedList.clear`</span>
<span class="sd">    * :func:`SortedList.discard`</span>
<span class="sd">    * :func:`SortedList.remove`</span>
<span class="sd">    * :func:`SortedList.pop`</span>
<span class="sd">    * :func:`SortedList.__delitem__`</span>

<span class="sd">    Methods for looking up values:</span>

<span class="sd">    * :func:`SortedList.bisect_left`</span>
<span class="sd">    * :func:`SortedList.bisect_right`</span>
<span class="sd">    * :func:`SortedList.count`</span>
<span class="sd">    * :func:`SortedList.index`</span>
<span class="sd">    * :func:`SortedList.__contains__`</span>
<span class="sd">    * :func:`SortedList.__getitem__`</span>

<span class="sd">    Methods for iterating values:</span>

<span class="sd">    * :func:`SortedList.irange`</span>
<span class="sd">    * :func:`SortedList.islice`</span>
<span class="sd">    * :func:`SortedList.__iter__`</span>
<span class="sd">    * :func:`SortedList.__reversed__`</span>

<span class="sd">    Methods for miscellany:</span>

<span class="sd">    * :func:`SortedList.copy`</span>
<span class="sd">    * :func:`SortedList.__len__`</span>
<span class="sd">    * :func:`SortedList.__repr__`</span>
<span class="sd">    * :func:`SortedList._check`</span>
<span class="sd">    * :func:`SortedList._reset`</span>

<span class="sd">    Sorted lists use lexicographical ordering semantics when compared to other</span>
<span class="sd">    sequences.</span>

<span class="sd">    Some methods of mutable sequences are not supported and will raise</span>
<span class="sd">    not-implemented error.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DEFAULT_LOAD_FACTOR</span> <span class="o">=</span> <span class="mi">1000</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize sorted list instance.</span>

<span class="sd">        Optional `iterable` argument provides an initial iterable of values to</span>
<span class="sd">        initialize the sorted list.</span>

<span class="sd">        Runtime complexity: `O(n*log(n))`</span>

<span class="sd">        &gt;&gt;&gt; sl = SortedList()</span>
<span class="sd">        &gt;&gt;&gt; sl</span>
<span class="sd">        SortedList([])</span>
<span class="sd">        &gt;&gt;&gt; sl = SortedList([3, 1, 2, 5, 4])</span>
<span class="sd">        &gt;&gt;&gt; sl</span>
<span class="sd">        SortedList([1, 2, 3, 4, 5])</span>

<span class="sd">        :param iterable: initial values (optional)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DEFAULT_LOAD_FACTOR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">iterable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">iterable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new sorted list or sorted-key list instance.</span>

<span class="sd">        Optional `key`-function argument will return an instance of subtype</span>
<span class="sd">        :class:`SortedKeyList`.</span>

<span class="sd">        &gt;&gt;&gt; sl = SortedList()</span>
<span class="sd">        &gt;&gt;&gt; isinstance(sl, SortedList)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; sl = SortedList(key=lambda x: -x)</span>
<span class="sd">        &gt;&gt;&gt; isinstance(sl, SortedList)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; isinstance(sl, SortedKeyList)</span>
<span class="sd">        True</span>

<span class="sd">        :param iterable: initial values (optional)</span>
<span class="sd">        :param key: function used to extract comparison key (optional)</span>
<span class="sd">        :return: sorted list or sorted-key list instance</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=unused-argument</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="n">SortedList</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">SortedKeyList</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;inherit SortedKeyList for key argument&#39;</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pylint: disable=useless-return</span>
        <span class="sd">&quot;&quot;&quot;Function used to extract comparison key from values.</span>

<span class="sd">        Sorted list compares values directly so the key function is none.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>


    <span class="k">def</span> <span class="nf">_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">load</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset sorted list load factor.</span>

<span class="sd">        The `load` specifies the load-factor of the list. The default load</span>
<span class="sd">        factor of 1000 works well for lists from tens to tens-of-millions of</span>
<span class="sd">        values. Good practice is to use a value that is the cube root of the</span>
<span class="sd">        list size. With billions of elements, the best load factor depends on</span>
<span class="sd">        your usage. It&#39;s best to leave the load factor at the default until you</span>
<span class="sd">        start benchmarking.</span>

<span class="sd">        See :doc:`implementation` and :doc:`performance-scale` for more</span>
<span class="sd">        information.</span>

<span class="sd">        Runtime complexity: `O(n)`</span>

<span class="sd">        :param int load: load-factor for sorted list sublists</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">,</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">=</span> <span class="n">load</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all values from sorted list.</span>

<span class="sd">        Runtime complexity: `O(n)`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[:]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">[:]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">_clear</span> <span class="o">=</span> <span class="n">clear</span>


    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add `value` to sorted list.</span>

<span class="sd">        Runtime complexity: `O(log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; sl = SortedList()</span>
<span class="sd">        &gt;&gt;&gt; sl.add(3)</span>
<span class="sd">        &gt;&gt;&gt; sl.add(1)</span>
<span class="sd">        &gt;&gt;&gt; sl.add(2)</span>
<span class="sd">        &gt;&gt;&gt; sl</span>
<span class="sd">        SortedList([1, 2, 3])</span>

<span class="sd">        :param value: value to add to sorted list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                <span class="n">pos</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">insort</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_lists</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">value</span><span class="p">])</span>
            <span class="n">_maxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">+=</span> <span class="mi">1</span>


    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Split sublists with length greater than double the load-factor.</span>

<span class="sd">        Updates the index when the sublist length is less than double the load</span>
<span class="sd">        level. This requires incrementing the nodes in a traversal from the</span>
<span class="sd">        leaf node to the root. For an example traversal see</span>
<span class="sd">        ``SortedList._loc``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">_load</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

            <span class="n">_lists_pos</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="n">half</span> <span class="o">=</span> <span class="n">_lists_pos</span><span class="p">[</span><span class="n">_load</span><span class="p">:]</span>
            <span class="k">del</span> <span class="n">_lists_pos</span><span class="p">[</span><span class="n">_load</span><span class="p">:]</span>
            <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">_lists_pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">_lists</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">half</span><span class="p">)</span>
            <span class="n">_maxes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">half</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">del</span> <span class="n">_index</span><span class="p">[:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_index</span><span class="p">:</span>
                <span class="n">child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="n">pos</span>
                <span class="k">while</span> <span class="n">child</span><span class="p">:</span>
                    <span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">child</span> <span class="o">=</span> <span class="p">(</span><span class="n">child</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
                <span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>


    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update sorted list by adding all values from `iterable`.</span>

<span class="sd">        Runtime complexity: `O(k*log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; sl = SortedList()</span>
<span class="sd">        &gt;&gt;&gt; sl.update([3, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; sl</span>
<span class="sd">        SortedList([1, 2, 3])</span>

<span class="sd">        :param iterable: iterable of values to add</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
        <span class="n">values</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
                <span class="n">values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">_lists</span><span class="p">))</span>
                <span class="n">values</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_add</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span>
                <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                    <span class="n">_add</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="n">_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span>
        <span class="n">_lists</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">pos</span><span class="p">:(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">_load</span><span class="p">)]</span>
                      <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">_load</span><span class="p">))</span>
        <span class="n">_maxes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sublist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">_lists</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[:]</span>

    <span class="n">_update</span> <span class="o">=</span> <span class="n">update</span>


    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if `value` is an element of the sorted list.</span>

<span class="sd">        ``sl.__contains__(value)`` &lt;==&gt; ``value in sl``</span>

<span class="sd">        Runtime complexity: `O(log(n))`</span>

<span class="sd">        &gt;&gt;&gt; sl = SortedList([1, 2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; 3 in sl</span>
<span class="sd">        True</span>

<span class="sd">        :param value: search for value in sorted list</span>
<span class="sd">        :return: true if `value` in sorted list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span>


    <span class="k">def</span> <span class="nf">discard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove `value` from sorted list if it is a member.</span>

<span class="sd">        If `value` is not a member, do nothing.</span>

<span class="sd">        Runtime complexity: `O(log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; sl = SortedList([1, 2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; sl.discard(5)</span>
<span class="sd">        &gt;&gt;&gt; sl.discard(0)</span>
<span class="sd">        &gt;&gt;&gt; sl == [1, 2, 3, 4]</span>
<span class="sd">        True</span>

<span class="sd">        :param value: `value` to discard from sorted list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove `value` from sorted list; `value` must be a member.</span>

<span class="sd">        If `value` is not a member, raise ValueError.</span>

<span class="sd">        Runtime complexity: `O(log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; sl = SortedList([1, 2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; sl.remove(5)</span>
<span class="sd">        &gt;&gt;&gt; sl == [1, 2, 3, 4]</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; sl.remove(0)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        ValueError: 0 not in list</span>

<span class="sd">        :param value: `value` to remove from sorted list</span>
<span class="sd">        :raises ValueError: if `value` is not in sorted list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1"> not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1"> not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1"> not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete value at the given `(pos, idx)`.</span>

<span class="sd">        Combines lists that are less than half the load level.</span>

<span class="sd">        Updates the index when the sublist length is more than half the load</span>
<span class="sd">        level. This requires decrementing the nodes in a traversal from the</span>
<span class="sd">        leaf node to the root. For an example traversal see</span>
<span class="sd">        ``SortedList._loc``.</span>

<span class="sd">        :param int pos: lists index</span>
<span class="sd">        :param int idx: sublist index</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
        <span class="n">_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>

        <span class="n">_lists_pos</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>

        <span class="k">del</span> <span class="n">_lists_pos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">len_lists_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists_pos</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">len_lists_pos</span> <span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">_lists_pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">_index</span><span class="p">:</span>
                <span class="n">child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="n">pos</span>
                <span class="k">while</span> <span class="n">child</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">child</span> <span class="o">=</span> <span class="p">(</span><span class="n">child</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
                <span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pos</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">prev</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">_lists</span><span class="p">[</span><span class="n">prev</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
            <span class="n">_maxes</span><span class="p">[</span><span class="n">prev</span><span class="p">]</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">prev</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">del</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_index</span><span class="p">[:]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">len_lists_pos</span><span class="p">:</span>
            <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">_lists_pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_index</span><span class="p">[:]</span>


    <span class="k">def</span> <span class="nf">_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert an index pair (lists index, sublist index) into a single</span>
<span class="sd">        index number that corresponds to the position of the value in the</span>
<span class="sd">        sorted list.</span>

<span class="sd">        Many queries require the index be built. Details of the index are</span>
<span class="sd">        described in ``SortedList._build_index``.</span>

<span class="sd">        Indexing requires traversing the tree from a leaf node to the root. The</span>
<span class="sd">        parent of each node is easily computable at ``(pos - 1) // 2``.</span>

<span class="sd">        Left-child nodes are always at odd indices and right-child nodes are</span>
<span class="sd">        always at even indices.</span>

<span class="sd">        When traversing up from a right-child node, increment the total by the</span>
<span class="sd">        left-child node.</span>

<span class="sd">        The final index is the sum from traversal and the index in the sublist.</span>

<span class="sd">        For example, using the index from ``SortedList._build_index``::</span>

<span class="sd">            _index = 14 5 9 3 2 4 5</span>
<span class="sd">            _offset = 3</span>

<span class="sd">        Tree::</span>

<span class="sd">                 14</span>
<span class="sd">              5      9</span>
<span class="sd">            3   2  4   5</span>

<span class="sd">        Converting an index pair (2, 3) into a single index involves iterating</span>
<span class="sd">        like so:</span>

<span class="sd">        1. Starting at the leaf node: offset + alpha = 3 + 2 = 5. We identify</span>
<span class="sd">           the node as a left-child node. At such nodes, we simply traverse to</span>
<span class="sd">           the parent.</span>

<span class="sd">        2. At node 9, position 2, we recognize the node as a right-child node</span>
<span class="sd">           and accumulate the left-child in our total. Total is now 5 and we</span>
<span class="sd">           traverse to the parent at position 0.</span>

<span class="sd">        3. Iteration ends at the root.</span>

<span class="sd">        The index is then the sum of the total and sublist index: 5 + 3 = 8.</span>

<span class="sd">        :param int pos: lists index</span>
<span class="sd">        :param int idx: sublist index</span>
<span class="sd">        :return: index in sorted list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pos</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">idx</span>

        <span class="n">_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_index</span><span class="p">()</span>

        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Increment pos to point in the index to len(self._lists[pos]).</span>

        <span class="n">pos</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span>

        <span class="c1"># Iterate until reaching the root of the index tree at pos = 0.</span>

        <span class="k">while</span> <span class="n">pos</span><span class="p">:</span>

            <span class="c1"># Right-child nodes are at odd indices. At such indices</span>
            <span class="c1"># account the total below the left child node.</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="n">_index</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Advance pos to the parent node.</span>

            <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">total</span> <span class="o">+</span> <span class="n">idx</span>


    <span class="k">def</span> <span class="nf">_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert an index into an index pair (lists index, sublist index)</span>
<span class="sd">        that can be used to access the corresponding lists position.</span>

<span class="sd">        Many queries require the index be built. Details of the index are</span>
<span class="sd">        described in ``SortedList._build_index``.</span>

<span class="sd">        Indexing requires traversing the tree to a leaf node. Each node has two</span>
<span class="sd">        children which are easily computable. Given an index, pos, the</span>
<span class="sd">        left-child is at ``pos * 2 + 1`` and the right-child is at ``pos * 2 +</span>
<span class="sd">        2``.</span>

<span class="sd">        When the index is less than the left-child, traversal moves to the</span>
<span class="sd">        left sub-tree. Otherwise, the index is decremented by the left-child</span>
<span class="sd">        and traversal moves to the right sub-tree.</span>

<span class="sd">        At a child node, the indexing pair is computed from the relative</span>
<span class="sd">        position of the child node as compared with the offset and the remaining</span>
<span class="sd">        index.</span>

<span class="sd">        For example, using the index from ``SortedList._build_index``::</span>

<span class="sd">            _index = 14 5 9 3 2 4 5</span>
<span class="sd">            _offset = 3</span>

<span class="sd">        Tree::</span>

<span class="sd">                 14</span>
<span class="sd">              5      9</span>
<span class="sd">            3   2  4   5</span>

<span class="sd">        Indexing position 8 involves iterating like so:</span>

<span class="sd">        1. Starting at the root, position 0, 8 is compared with the left-child</span>
<span class="sd">           node (5) which it is greater than. When greater the index is</span>
<span class="sd">           decremented and the position is updated to the right child node.</span>

<span class="sd">        2. At node 9 with index 3, we again compare the index to the left-child</span>
<span class="sd">           node with value 4. Because the index is the less than the left-child</span>
<span class="sd">           node, we simply traverse to the left.</span>

<span class="sd">        3. At node 4 with index 3, we recognize that we are at a leaf node and</span>
<span class="sd">           stop iterating.</span>

<span class="sd">        4. To compute the sublist index, we subtract the offset from the index</span>
<span class="sd">           of the leaf node: 5 - 3 = 2. To compute the index in the sublist, we</span>
<span class="sd">           simply use the index remaining from iteration. In this case, 3.</span>

<span class="sd">        The final index pair from our example is (2, 3) which corresponds to</span>
<span class="sd">        index 8 in the sorted list.</span>

<span class="sd">        :param int idx: index in sorted list</span>
<span class="sd">        :return: (lists index, sublist index) pair</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">last_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="n">idx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">last_len</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">last_len</span> <span class="o">+</span> <span class="n">idx</span>

            <span class="n">idx</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

            <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;list index out of range&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;list index out of range&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span>

        <span class="n">_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_index</span><span class="p">()</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">child</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">len_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_index</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">child</span> <span class="o">&lt;</span> <span class="n">len_index</span><span class="p">:</span>
            <span class="n">index_child</span> <span class="o">=</span> <span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">index_child</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">child</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">-=</span> <span class="n">index_child</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">child</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">child</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_build_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build a positional index for indexing the sorted list.</span>

<span class="sd">        Indexes are represented as binary trees in a dense array notation</span>
<span class="sd">        similar to a binary heap.</span>

<span class="sd">        For example, given a lists representation storing integers::</span>

<span class="sd">            0: [1, 2, 3]</span>
<span class="sd">            1: [4, 5]</span>
<span class="sd">            2: [6, 7, 8, 9]</span>
<span class="sd">            3: [10, 11, 12, 13, 14]</span>

<span class="sd">        The first transformation maps the sub-lists by their length. The</span>
<span class="sd">        first row of the index is the length of the sub-lists::</span>

<span class="sd">            0: [3, 2, 4, 5]</span>

<span class="sd">        Each row after that is the sum of consecutive pairs of the previous</span>
<span class="sd">        row::</span>

<span class="sd">            1: [5, 9]</span>
<span class="sd">            2: [14]</span>

<span class="sd">        Finally, the index is built by concatenating these lists together::</span>

<span class="sd">            _index = [14, 5, 9, 3, 2, 4, 5]</span>

<span class="sd">        An offset storing the start of the first row is also stored::</span>

<span class="sd">            _offset = 3</span>

<span class="sd">        When built, the index can be used for efficient indexing into the list.</span>
<span class="sd">        See the comment and notes on ``SortedList._pos`` for details.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">row0</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">row0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span>

        <span class="n">head</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">row0</span><span class="p">)</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
        <span class="n">row1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">starmap</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">row1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">row1</span> <span class="o">+</span> <span class="n">row0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span>

        <span class="n">size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">row1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">row1</span><span class="p">)))</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="p">[</span><span class="n">row0</span><span class="p">,</span> <span class="n">row1</span><span class="p">]</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">head</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
            <span class="n">row</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">starmap</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">)))</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

        <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">size</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>


    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove value at `index` from sorted list.</span>

<span class="sd">        ``sl.__delitem__(index)`` &lt;==&gt; ``del sl[index]``</span>

<span class="sd">        Supports slicing.</span>

<span class="sd">        Runtime complexity: `O(log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; sl = SortedList(&#39;abcde&#39;)</span>
<span class="sd">        &gt;&gt;&gt; del sl[2]</span>
<span class="sd">        &gt;&gt;&gt; sl</span>
<span class="sd">        SortedList([&#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;e&#39;])</span>
<span class="sd">        &gt;&gt;&gt; del sl[:2]</span>
<span class="sd">        &gt;&gt;&gt; sl</span>
<span class="sd">        SortedList([&#39;d&#39;, &#39;e&#39;])</span>

<span class="sd">        :param index: integer or slice for indexing</span>
<span class="sd">        :raises IndexError: if index out of range</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">stop</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">&lt;=</span> <span class="mi">8</span> <span class="o">*</span> <span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">):</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
                        <span class="n">values</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

            <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

            <span class="c1"># Delete items from greatest index to least so</span>
            <span class="c1"># that the indices remain valid throughout iteration.</span>

            <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

            <span class="n">_pos</span><span class="p">,</span> <span class="n">_delete</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span>

            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">pos</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">_pos</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="n">_delete</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lookup value at `index` in sorted list.</span>

<span class="sd">        ``sl.__getitem__(index)`` &lt;==&gt; ``sl[index]``</span>

<span class="sd">        Supports slicing.</span>

<span class="sd">        Runtime complexity: `O(log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; sl = SortedList(&#39;abcde&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sl[1]</span>
<span class="sd">        &#39;b&#39;</span>
<span class="sd">        &gt;&gt;&gt; sl[-1]</span>
<span class="sd">        &#39;e&#39;</span>
<span class="sd">        &gt;&gt;&gt; sl[2:5]</span>
<span class="sd">        [&#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span>

<span class="sd">        :param index: integer or slice for indexing</span>
<span class="sd">        :return: value or list of values</span>
<span class="sd">        :raises IndexError: if index out of range</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
                <span class="c1"># Whole slice optimization: start to stop slices the whole</span>
                <span class="c1"># sorted list.</span>

                <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">stop</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">,</span> <span class="p">[])</span>

                <span class="n">start_pos</span><span class="p">,</span> <span class="n">start_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
                <span class="n">start_list</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">start_pos</span><span class="p">]</span>
                <span class="n">stop_idx</span> <span class="o">=</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>

                <span class="c1"># Small slice optimization: start index and stop index are</span>
                <span class="c1"># within the start list.</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_list</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">stop_idx</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">start_list</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">stop_idx</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">stop</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
                    <span class="n">stop_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">stop_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">stop_pos</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stop_pos</span><span class="p">,</span> <span class="n">stop_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>

                <span class="n">prefix</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">start_pos</span><span class="p">][</span><span class="n">start_idx</span><span class="p">:]</span>
                <span class="n">middle</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[(</span><span class="n">start_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="n">stop_pos</span><span class="p">]</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="n">middle</span><span class="p">,</span> <span class="n">prefix</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">stop_pos</span><span class="p">][:</span><span class="n">stop_idx</span><span class="p">]</span>

                <span class="k">return</span> <span class="n">result</span>

            <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">result</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">result</span>

            <span class="c1"># Return a list because a negative step could</span>
            <span class="c1"># reverse the order of the items and this could</span>
            <span class="c1"># be the desired behavior.</span>

            <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">_lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;list index out of range&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">return</span> <span class="n">_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>

            <span class="n">len_last</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="o">-</span><span class="n">len_last</span> <span class="o">&lt;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">len_last</span> <span class="o">+</span> <span class="n">index</span><span class="p">]</span>

            <span class="n">pos</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>

    <span class="n">_getitem</span> <span class="o">=</span> <span class="fm">__getitem__</span>


    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raise not-implemented error.</span>

<span class="sd">        ``sl.__setitem__(index, value)`` &lt;==&gt; ``sl[index] = value``</span>

<span class="sd">        :raises NotImplementedError: use ``del sl[index]`` and</span>
<span class="sd">            ``sl.add(value)`` instead</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;use ``del sl[index]`` and ``sl.add(value)`` instead&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator over the sorted list.</span>

<span class="sd">        ``sl.__iter__()`` &lt;==&gt; ``iter(sl)``</span>

<span class="sd">        Iterating the sorted list while adding or deleting values may raise a</span>
<span class="sd">        :exc:`RuntimeError` or fail to iterate over all values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a reverse iterator over the sorted list.</span>

<span class="sd">        ``sl.__reversed__()`` &lt;==&gt; ``reversed(sl)``</span>

<span class="sd">        Iterating the sorted list while adding or deleting values may raise a</span>
<span class="sd">        :exc:`RuntimeError` or fail to iterate over all values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">reversed</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)))</span>


    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raise not-implemented error.</span>

<span class="sd">        Sorted list maintains values in ascending sort order. Values may not be</span>
<span class="sd">        reversed in-place.</span>

<span class="sd">        Use ``reversed(sl)`` for an iterator over values in descending sort</span>
<span class="sd">        order.</span>

<span class="sd">        Implemented to override `MutableSequence.reverse` which provides an</span>
<span class="sd">        erroneous default implementation.</span>

<span class="sd">        :raises NotImplementedError: use ``reversed(sl)`` instead</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;use ``reversed(sl)`` instead&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">islice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator that slices sorted list from `start` to `stop`.</span>

<span class="sd">        The `start` and `stop` index are treated inclusive and exclusive,</span>
<span class="sd">        respectively.</span>

<span class="sd">        Both `start` and `stop` default to `None` which is automatically</span>
<span class="sd">        inclusive of the beginning and end of the sorted list.</span>

<span class="sd">        When `reverse` is `True` the values are yielded from the iterator in</span>
<span class="sd">        reverse order; `reverse` defaults to `False`.</span>

<span class="sd">        &gt;&gt;&gt; sl = SortedList(&#39;abcdefghij&#39;)</span>
<span class="sd">        &gt;&gt;&gt; it = sl.islice(2, 6)</span>
<span class="sd">        &gt;&gt;&gt; list(it)</span>
<span class="sd">        [&#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]</span>

<span class="sd">        :param int start: start index (inclusive)</span>
<span class="sd">        :param int stop: stop index (exclusive)</span>
<span class="sd">        :param bool reverse: yield values in reverse order</span>
<span class="sd">        :return: iterator</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_len</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>

        <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">stop</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>

        <span class="n">_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>

        <span class="n">min_pos</span><span class="p">,</span> <span class="n">min_idx</span> <span class="o">=</span> <span class="n">_pos</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="o">==</span> <span class="n">_len</span><span class="p">:</span>
            <span class="n">max_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_pos</span><span class="p">,</span> <span class="n">max_idx</span> <span class="o">=</span> <span class="n">_pos</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_islice</span><span class="p">(</span><span class="n">min_pos</span><span class="p">,</span> <span class="n">min_idx</span><span class="p">,</span> <span class="n">max_pos</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">,</span> <span class="n">reverse</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_islice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_pos</span><span class="p">,</span> <span class="n">min_idx</span><span class="p">,</span> <span class="n">max_pos</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">,</span> <span class="n">reverse</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator that slices sorted list using two index pairs.</span>

<span class="sd">        The index pairs are (min_pos, min_idx) and (max_pos, max_idx), the</span>
<span class="sd">        first inclusive and the latter exclusive. See `_pos` for details on how</span>
<span class="sd">        an index is converted to an index pair.</span>

<span class="sd">        When `reverse` is `True`, values are yielded from the iterator in</span>
<span class="sd">        reverse order.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>

        <span class="k">if</span> <span class="n">min_pos</span> <span class="o">&gt;</span> <span class="n">max_pos</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>

        <span class="k">if</span> <span class="n">min_pos</span> <span class="o">==</span> <span class="n">max_pos</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">min_idx</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">]</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>

            <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_idx</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">]</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>

        <span class="n">next_pos</span> <span class="o">=</span> <span class="n">min_pos</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">next_pos</span> <span class="o">==</span> <span class="n">max_pos</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="n">min_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_idx</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">]))</span>
                <span class="n">max_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_idx</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">chain</span><span class="p">(</span>
                    <span class="nb">map</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">max_pos</span><span class="p">]</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">max_indices</span><span class="p">)),</span>
                    <span class="nb">map</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">]</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">min_indices</span><span class="p">)),</span>
                <span class="p">)</span>

            <span class="n">min_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_idx</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">]))</span>
            <span class="n">max_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_idx</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">chain</span><span class="p">(</span>
                <span class="nb">map</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">]</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span> <span class="n">min_indices</span><span class="p">),</span>
                <span class="nb">map</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">max_pos</span><span class="p">]</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span> <span class="n">max_indices</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">min_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_idx</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">]))</span>
            <span class="n">sublist_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">next_pos</span><span class="p">,</span> <span class="n">max_pos</span><span class="p">)</span>
            <span class="n">sublists</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">_lists</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">sublist_indices</span><span class="p">))</span>
            <span class="n">max_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_idx</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">chain</span><span class="p">(</span>
                <span class="nb">map</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">max_pos</span><span class="p">]</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">max_indices</span><span class="p">)),</span>
                <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">reversed</span><span class="p">,</span> <span class="n">sublists</span><span class="p">)),</span>
                <span class="nb">map</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">]</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">min_indices</span><span class="p">)),</span>
            <span class="p">)</span>

        <span class="n">min_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_idx</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">]))</span>
        <span class="n">sublist_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">next_pos</span><span class="p">,</span> <span class="n">max_pos</span><span class="p">)</span>
        <span class="n">sublists</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">_lists</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span> <span class="n">sublist_indices</span><span class="p">)</span>
        <span class="n">max_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chain</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">]</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span> <span class="n">min_indices</span><span class="p">),</span>
            <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">sublists</span><span class="p">),</span>
            <span class="nb">map</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">max_pos</span><span class="p">]</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span> <span class="n">max_indices</span><span class="p">),</span>
        <span class="p">)</span>


    <span class="k">def</span> <span class="nf">irange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minimum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maximum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
               <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an iterator of values between `minimum` and `maximum`.</span>

<span class="sd">        Both `minimum` and `maximum` default to `None` which is automatically</span>
<span class="sd">        inclusive of the beginning and end of the sorted list.</span>

<span class="sd">        The argument `inclusive` is a pair of booleans that indicates whether</span>
<span class="sd">        the minimum and maximum ought to be included in the range,</span>
<span class="sd">        respectively. The default is ``(True, True)`` such that the range is</span>
<span class="sd">        inclusive of both minimum and maximum.</span>

<span class="sd">        When `reverse` is `True` the values are yielded from the iterator in</span>
<span class="sd">        reverse order; `reverse` defaults to `False`.</span>

<span class="sd">        &gt;&gt;&gt; sl = SortedList(&#39;abcdefghij&#39;)</span>
<span class="sd">        &gt;&gt;&gt; it = sl.irange(&#39;c&#39;, &#39;f&#39;)</span>
<span class="sd">        &gt;&gt;&gt; list(it)</span>
<span class="sd">        [&#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]</span>

<span class="sd">        :param minimum: minimum value to start iterating</span>
<span class="sd">        :param maximum: maximum value to stop iterating</span>
<span class="sd">        :param inclusive: pair of booleans</span>
<span class="sd">        :param bool reverse: yield values in reverse order</span>
<span class="sd">        :return: iterator</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>

        <span class="c1"># Calculate the minimum (pos, idx) pair. By default this location</span>
        <span class="c1"># will be inclusive in our calculation.</span>

        <span class="k">if</span> <span class="n">minimum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_pos</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">min_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inclusive</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">min_pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">minimum</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">min_pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>

                <span class="n">min_idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">],</span> <span class="n">minimum</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_pos</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">minimum</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">min_pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>

                <span class="n">min_idx</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">min_pos</span><span class="p">],</span> <span class="n">minimum</span><span class="p">)</span>

        <span class="c1"># Calculate the maximum (pos, idx) pair. By default this location</span>
        <span class="c1"># will be exclusive in our calculation.</span>

        <span class="k">if</span> <span class="n">maximum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">max_pos</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inclusive</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">max_pos</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">maximum</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">max_pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                    <span class="n">max_pos</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">max_pos</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">max_idx</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">max_pos</span><span class="p">],</span> <span class="n">maximum</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">maximum</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">max_pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                    <span class="n">max_pos</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">max_pos</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">max_idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">max_pos</span><span class="p">],</span> <span class="n">maximum</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_islice</span><span class="p">(</span><span class="n">min_pos</span><span class="p">,</span> <span class="n">min_idx</span><span class="p">,</span> <span class="n">max_pos</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">,</span> <span class="n">reverse</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the size of the sorted list.</span>

<span class="sd">        ``sl.__len__()`` &lt;==&gt; ``len(sl)``</span>

<span class="sd">        :return: size of sorted list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>


    <span class="k">def</span> <span class="nf">bisect_left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an index to insert `value` in the sorted list.</span>

<span class="sd">        If the `value` is already present, the insertion point will be before</span>
<span class="sd">        (to the left of) any existing values.</span>

<span class="sd">        Similar to the `bisect` module in the standard library.</span>

<span class="sd">        Runtime complexity: `O(log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; sl = SortedList([10, 11, 12, 13, 14])</span>
<span class="sd">        &gt;&gt;&gt; sl.bisect_left(12)</span>
<span class="sd">        2</span>

<span class="sd">        :param value: insertion index of value in sorted list</span>
<span class="sd">        :return: index</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">bisect_right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an index to insert `value` in the sorted list.</span>

<span class="sd">        Similar to `bisect_left`, but if `value` is already present, the</span>
<span class="sd">        insertion point will be after (to the right of) any existing values.</span>

<span class="sd">        Similar to the `bisect` module in the standard library.</span>

<span class="sd">        Runtime complexity: `O(log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; sl = SortedList([10, 11, 12, 13, 14])</span>
<span class="sd">        &gt;&gt;&gt; sl.bisect_right(12)</span>
<span class="sd">        3</span>

<span class="sd">        :param value: insertion index of value in sorted list</span>
<span class="sd">        :return: index</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="n">bisect</span> <span class="o">=</span> <span class="n">bisect_right</span>
    <span class="n">_bisect_right</span> <span class="o">=</span> <span class="n">bisect_right</span>


    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of occurrences of `value` in the sorted list.</span>

<span class="sd">        Runtime complexity: `O(log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; sl = SortedList([1, 2, 2, 3, 3, 3, 4, 4, 4, 4])</span>
<span class="sd">        &gt;&gt;&gt; sl.count(3)</span>
<span class="sd">        3</span>

<span class="sd">        :param value: value to count in sorted list</span>
<span class="sd">        :return: count</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">pos_left</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos_left</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">idx_left</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos_left</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">pos_right</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos_right</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">(</span><span class="n">pos_left</span><span class="p">,</span> <span class="n">idx_left</span><span class="p">)</span>

        <span class="n">idx_right</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos_right</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos_left</span> <span class="o">==</span> <span class="n">pos_right</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">idx_right</span> <span class="o">-</span> <span class="n">idx_left</span>

        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">(</span><span class="n">pos_right</span><span class="p">,</span> <span class="n">idx_right</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">(</span><span class="n">pos_left</span><span class="p">,</span> <span class="n">idx_left</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span>


    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a shallow copy of the sorted list.</span>

<span class="sd">        Runtime complexity: `O(n)`</span>

<span class="sd">        :return: new sorted list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">__copy__</span> <span class="o">=</span> <span class="n">copy</span>


    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raise not-implemented error.</span>

<span class="sd">        Implemented to override `MutableSequence.append` which provides an</span>
<span class="sd">        erroneous default implementation.</span>

<span class="sd">        :raises NotImplementedError: use ``sl.add(value)`` instead</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;use ``sl.add(value)`` instead&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raise not-implemented error.</span>

<span class="sd">        Implemented to override `MutableSequence.extend` which provides an</span>
<span class="sd">        erroneous default implementation.</span>

<span class="sd">        :raises NotImplementedError: use ``sl.update(values)`` instead</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;use ``sl.update(values)`` instead&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raise not-implemented error.</span>

<span class="sd">        :raises NotImplementedError: use ``sl.add(value)`` instead</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;use ``sl.add(value)`` instead&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove and return value at `index` in sorted list.</span>

<span class="sd">        Raise :exc:`IndexError` if the sorted list is empty or index is out of</span>
<span class="sd">        range.</span>

<span class="sd">        Negative indices are supported.</span>

<span class="sd">        Runtime complexity: `O(log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; sl = SortedList(&#39;abcde&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sl.pop()</span>
<span class="sd">        &#39;e&#39;</span>
<span class="sd">        &gt;&gt;&gt; sl.pop(2)</span>
<span class="sd">        &#39;c&#39;</span>
<span class="sd">        &gt;&gt;&gt; sl</span>
<span class="sd">        SortedList([&#39;a&#39;, &#39;b&#39;, &#39;d&#39;])</span>

<span class="sd">        :param int index: index of value (default -1)</span>
<span class="sd">        :return: value</span>
<span class="sd">        :raises IndexError: if index is out of range</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;pop index out of range&#39;</span><span class="p">)</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>

        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">val</span>

        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">loc</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">val</span>

        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">val</span>

        <span class="n">len_last</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="o">-</span><span class="n">len_last</span> <span class="o">&lt;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_lists</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">len_last</span> <span class="o">+</span> <span class="n">index</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">loc</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">val</span>

        <span class="n">pos</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>


    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return first index of value in sorted list.</span>

<span class="sd">        Raise ValueError if `value` is not present.</span>

<span class="sd">        Index must be between `start` and `stop` for the `value` to be</span>
<span class="sd">        considered present. The default value, None, for `start` and `stop`</span>
<span class="sd">        indicate the beginning and end of the sorted list.</span>

<span class="sd">        Negative indices are supported.</span>

<span class="sd">        Runtime complexity: `O(log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; sl = SortedList(&#39;abcde&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sl.index(&#39;d&#39;)</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; sl.index(&#39;z&#39;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        ValueError: &#39;z&#39; is not in list</span>

<span class="sd">        :param value: value in sorted list</span>
<span class="sd">        :param int start: start index (default None, start of sorted list)</span>
<span class="sd">        :param int stop: stop index (default None, end of sorted list)</span>
<span class="sd">        :return: index of value</span>
<span class="sd">        :raises ValueError: if value is not present</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_len</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">_len</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">_len</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">+=</span> <span class="n">_len</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="n">_len</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">_len</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
        <span class="n">pos_left</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos_left</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">idx_left</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos_left</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos_left</span><span class="p">][</span><span class="n">idx_left</span><span class="p">]</span> <span class="o">!=</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="n">stop</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">(</span><span class="n">pos_left</span><span class="p">,</span> <span class="n">idx_left</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">left</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">stop</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">left</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bisect_right</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">start</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>


    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return new sorted list containing all values in both sequences.</span>

<span class="sd">        ``sl.__add__(other)`` &lt;==&gt; ``sl + other``</span>

<span class="sd">        Values in `other` do not need to be in sorted order.</span>

<span class="sd">        Runtime complexity: `O(n*log(n))`</span>

<span class="sd">        &gt;&gt;&gt; sl1 = SortedList(&#39;bat&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sl2 = SortedList(&#39;cat&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sl1 + sl2</span>
<span class="sd">        SortedList([&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;t&#39;, &#39;t&#39;])</span>

<span class="sd">        :param other: other iterable</span>
<span class="sd">        :return: new sorted list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="fm">__radd__</span> <span class="o">=</span> <span class="fm">__add__</span>


    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update sorted list with values from `other`.</span>

<span class="sd">        ``sl.__iadd__(other)`` &lt;==&gt; ``sl += other``</span>

<span class="sd">        Values in `other` do not need to be in sorted order.</span>

<span class="sd">        Runtime complexity: `O(k*log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; sl = SortedList(&#39;bat&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sl += &#39;cat&#39;</span>
<span class="sd">        &gt;&gt;&gt; sl</span>
<span class="sd">        SortedList([&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;t&#39;, &#39;t&#39;])</span>

<span class="sd">        :param other: other iterable</span>
<span class="sd">        :return: existing sorted list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>


    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return new sorted list with `num` shallow copies of values.</span>

<span class="sd">        ``sl.__mul__(num)`` &lt;==&gt; ``sl * num``</span>

<span class="sd">        Runtime complexity: `O(n*log(n))`</span>

<span class="sd">        &gt;&gt;&gt; sl = SortedList(&#39;abc&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sl * 3</span>
<span class="sd">        SortedList([&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;, &#39;c&#39;])</span>

<span class="sd">        :param int num: count of shallow copies</span>
<span class="sd">        :return: new sorted list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">,</span> <span class="p">[])</span> <span class="o">*</span> <span class="n">num</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="fm">__rmul__</span> <span class="o">=</span> <span class="fm">__mul__</span>


    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the sorted list with `num` shallow copies of values.</span>

<span class="sd">        ``sl.__imul__(num)`` &lt;==&gt; ``sl *= num``</span>

<span class="sd">        Runtime complexity: `O(n*log(n))`</span>

<span class="sd">        &gt;&gt;&gt; sl = SortedList(&#39;abc&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sl *= 3</span>
<span class="sd">        &gt;&gt;&gt; sl</span>
<span class="sd">        SortedList([&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;, &#39;c&#39;])</span>

<span class="sd">        :param int num: count of shallow copies</span>
<span class="sd">        :return: existing sorted list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">,</span> <span class="p">[])</span> <span class="o">*</span> <span class="n">num</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>


    <span class="k">def</span> <span class="nf">__make_cmp</span><span class="p">(</span><span class="n">seq_op</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
        <span class="s2">&quot;Make comparator method.&quot;</span>
        <span class="k">def</span> <span class="nf">comparer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="s2">&quot;Compare method for sorted list and sequence.&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

            <span class="n">self_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>
            <span class="n">len_other</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">self_len</span> <span class="o">!=</span> <span class="n">len_other</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">seq_op</span> <span class="ow">is</span> <span class="n">eq</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">seq_op</span> <span class="ow">is</span> <span class="n">ne</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>

            <span class="k">for</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">alpha</span> <span class="o">!=</span> <span class="n">beta</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">seq_op</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">seq_op</span><span class="p">(</span><span class="n">self_len</span><span class="p">,</span> <span class="n">len_other</span><span class="p">)</span>

        <span class="n">seq_op_name</span> <span class="o">=</span> <span class="n">seq_op</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">comparer</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s1">&#39;__</span><span class="si">{0}</span><span class="s1">__&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">seq_op_name</span><span class="p">)</span>
        <span class="n">doc_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Return true if and only if sorted list is </span><span class="si">{0}</span><span class="s2"> `other`.</span>

<span class="s2">        ``sl.__</span><span class="si">{1}</span><span class="s2">__(other)`` &lt;==&gt; ``sl </span><span class="si">{2}</span><span class="s2"> other``</span>

<span class="s2">        Comparisons use lexicographical order as with sequences.</span>

<span class="s2">        Runtime complexity: `O(n)`</span>

<span class="s2">        :param other: `other` sequence</span>
<span class="s2">        :return: true if sorted list is </span><span class="si">{0}</span><span class="s2"> `other`</span>

<span class="s2">        &quot;&quot;&quot;</span>
        <span class="n">comparer</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">dedent</span><span class="p">(</span><span class="n">doc_str</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">seq_op_name</span><span class="p">,</span> <span class="n">symbol</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">comparer</span>


    <span class="fm">__eq__</span> <span class="o">=</span> <span class="n">__make_cmp</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="s1">&#39;==&#39;</span><span class="p">,</span> <span class="s1">&#39;equal to&#39;</span><span class="p">)</span>
    <span class="fm">__ne__</span> <span class="o">=</span> <span class="n">__make_cmp</span><span class="p">(</span><span class="n">ne</span><span class="p">,</span> <span class="s1">&#39;!=&#39;</span><span class="p">,</span> <span class="s1">&#39;not equal to&#39;</span><span class="p">)</span>
    <span class="fm">__lt__</span> <span class="o">=</span> <span class="n">__make_cmp</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">,</span> <span class="s1">&#39;less than&#39;</span><span class="p">)</span>
    <span class="fm">__gt__</span> <span class="o">=</span> <span class="n">__make_cmp</span><span class="p">(</span><span class="n">gt</span><span class="p">,</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;greater than&#39;</span><span class="p">)</span>
    <span class="fm">__le__</span> <span class="o">=</span> <span class="n">__make_cmp</span><span class="p">(</span><span class="n">le</span><span class="p">,</span> <span class="s1">&#39;&lt;=&#39;</span><span class="p">,</span> <span class="s1">&#39;less than or equal to&#39;</span><span class="p">)</span>
    <span class="fm">__ge__</span> <span class="o">=</span> <span class="n">__make_cmp</span><span class="p">(</span><span class="n">ge</span><span class="p">,</span> <span class="s1">&#39;&gt;=&#39;</span><span class="p">,</span> <span class="s1">&#39;greater than or equal to&#39;</span><span class="p">)</span>
    <span class="n">__make_cmp</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">__make_cmp</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="p">(</span><span class="n">values</span><span class="p">,))</span>


    <span class="nd">@recursive_repr</span><span class="p">()</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return string representation of sorted list.</span>

<span class="sd">        ``sl.__repr__()`` &lt;==&gt; ``repr(sl)``</span>

<span class="sd">        :return: string representation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">(</span><span class="si">{1!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check invariants of sorted list.</span>

<span class="sd">        Runtime complexity: `O(n)`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">&gt;=</span> <span class="mi">4</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>

            <span class="c1"># Check all sublists are sorted.</span>

            <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)):</span>
                    <span class="k">assert</span> <span class="n">sublist</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">sublist</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>

            <span class="c1"># Check beginning/end of sublists are sorted.</span>

            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)):</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Check _maxes index is the last value of each sublist.</span>

            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">)):</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Check sublist lengths are less than double load-factor.</span>

            <span class="n">double</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">double</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>

            <span class="c1"># Check sublist lengths are greater than half load-factor for all</span>
            <span class="c1"># but the last sublist.</span>

            <span class="n">half</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">half</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>

                <span class="c1"># Check index leaf nodes equal length of sublists.</span>

                <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)):</span>
                    <span class="n">leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="n">pos</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="n">leaf</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>

                <span class="c1"># Check index branch nodes are the sum of their children.</span>

                <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">):</span>
                    <span class="n">child</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">child</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">):</span>
                        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="k">elif</span> <span class="n">child</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">):</span>
                        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">child_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">child</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="k">assert</span> <span class="n">child_sum</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len_index&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len_maxes&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;maxes&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len_lists&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;lists&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>
            <span class="k">raise</span>


<span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="s2">&quot;Identity function.&quot;</span>
    <span class="k">return</span> <span class="n">value</span>


<span class="k">class</span> <span class="nc">SortedKeyList</span><span class="p">(</span><span class="n">SortedList</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sorted-key list is a subtype of sorted list.</span>

<span class="sd">    The sorted-key list maintains values in comparison order based on the</span>
<span class="sd">    result of a key function applied to every value.</span>

<span class="sd">    All the same methods that are available in :class:`SortedList` are also</span>
<span class="sd">    available in :class:`SortedKeyList`.</span>

<span class="sd">    Additional methods provided:</span>

<span class="sd">    * :attr:`SortedKeyList.key`</span>
<span class="sd">    * :func:`SortedKeyList.bisect_key_left`</span>
<span class="sd">    * :func:`SortedKeyList.bisect_key_right`</span>
<span class="sd">    * :func:`SortedKeyList.irange_key`</span>

<span class="sd">    Some examples below use:</span>

<span class="sd">    &gt;&gt;&gt; from operator import neg</span>
<span class="sd">    &gt;&gt;&gt; neg</span>
<span class="sd">    &lt;built-in function neg&gt;</span>
<span class="sd">    &gt;&gt;&gt; neg(1)</span>
<span class="sd">    -1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">identity</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize sorted-key list instance.</span>

<span class="sd">        Optional `iterable` argument provides an initial iterable of values to</span>
<span class="sd">        initialize the sorted-key list.</span>

<span class="sd">        Optional `key` argument defines a callable that, like the `key`</span>
<span class="sd">        argument to Python&#39;s `sorted` function, extracts a comparison key from</span>
<span class="sd">        each value. The default is the identity function.</span>

<span class="sd">        Runtime complexity: `O(n*log(n))`</span>

<span class="sd">        &gt;&gt;&gt; from operator import neg</span>
<span class="sd">        &gt;&gt;&gt; skl = SortedKeyList(key=neg)</span>
<span class="sd">        &gt;&gt;&gt; skl</span>
<span class="sd">        SortedKeyList([], key=&lt;built-in function neg&gt;)</span>
<span class="sd">        &gt;&gt;&gt; skl = SortedKeyList([3, 1, 2], key=neg)</span>
<span class="sd">        &gt;&gt;&gt; skl</span>
<span class="sd">        SortedKeyList([3, 2, 1], key=&lt;built-in function neg&gt;)</span>

<span class="sd">        :param iterable: initial values (optional)</span>
<span class="sd">        :param key: function used to extract comparison key (optional)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DEFAULT_LOAD_FACTOR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">iterable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">iterable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">identity</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Function used to extract comparison key from values.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span>


    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all values from sorted-key list.</span>

<span class="sd">        Runtime complexity: `O(n)`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[:]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">[:]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">[:]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[:]</span>

    <span class="n">_clear</span> <span class="o">=</span> <span class="n">clear</span>


    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add `value` to sorted-key list.</span>

<span class="sd">        Runtime complexity: `O(log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; from operator import neg</span>
<span class="sd">        &gt;&gt;&gt; skl = SortedKeyList(key=neg)</span>
<span class="sd">        &gt;&gt;&gt; skl.add(3)</span>
<span class="sd">        &gt;&gt;&gt; skl.add(1)</span>
<span class="sd">        &gt;&gt;&gt; skl.add(2)</span>
<span class="sd">        &gt;&gt;&gt; skl</span>
<span class="sd">        SortedKeyList([3, 2, 1], key=&lt;built-in function neg&gt;)</span>

<span class="sd">        :param value: value to add to sorted-key list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                <span class="n">pos</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span>
                <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_lists</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">value</span><span class="p">])</span>
            <span class="n">_keys</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">key</span><span class="p">])</span>
            <span class="n">_maxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">+=</span> <span class="mi">1</span>


    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Split sublists with length greater than double the load-factor.</span>

<span class="sd">        Updates the index when the sublist length is less than double the load</span>
<span class="sd">        level. This requires incrementing the nodes in a traversal from the</span>
<span class="sd">        leaf node to the root. For an example traversal see</span>
<span class="sd">        ``SortedList._loc``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
            <span class="n">_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span>

            <span class="n">_lists_pos</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="n">_keys_pos</span> <span class="o">=</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="n">half</span> <span class="o">=</span> <span class="n">_lists_pos</span><span class="p">[</span><span class="n">_load</span><span class="p">:]</span>
            <span class="n">half_keys</span> <span class="o">=</span> <span class="n">_keys_pos</span><span class="p">[</span><span class="n">_load</span><span class="p">:]</span>
            <span class="k">del</span> <span class="n">_lists_pos</span><span class="p">[</span><span class="n">_load</span><span class="p">:]</span>
            <span class="k">del</span> <span class="n">_keys_pos</span><span class="p">[</span><span class="n">_load</span><span class="p">:]</span>
            <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">_keys_pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">_lists</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">half</span><span class="p">)</span>
            <span class="n">_keys</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">half_keys</span><span class="p">)</span>
            <span class="n">_maxes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">half_keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">del</span> <span class="n">_index</span><span class="p">[:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_index</span><span class="p">:</span>
                <span class="n">child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="n">pos</span>
                <span class="k">while</span> <span class="n">child</span><span class="p">:</span>
                    <span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">child</span> <span class="o">=</span> <span class="p">(</span><span class="n">child</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
                <span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>


    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update sorted-key list by adding all values from `iterable`.</span>

<span class="sd">        Runtime complexity: `O(k*log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; from operator import neg</span>
<span class="sd">        &gt;&gt;&gt; skl = SortedKeyList(key=neg)</span>
<span class="sd">        &gt;&gt;&gt; skl.update([3, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; skl</span>
<span class="sd">        SortedKeyList([3, 2, 1], key=&lt;built-in function neg&gt;)</span>

<span class="sd">        :param iterable: iterable of values to add</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
        <span class="n">values</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
                <span class="n">values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">_lists</span><span class="p">))</span>
                <span class="n">values</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_add</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span>
                <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                    <span class="n">_add</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="n">_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span>
        <span class="n">_lists</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">pos</span><span class="p">:(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">_load</span><span class="p">)]</span>
                      <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">_load</span><span class="p">))</span>
        <span class="n">_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">,</span> <span class="n">_list</span><span class="p">))</span> <span class="k">for</span> <span class="n">_list</span> <span class="ow">in</span> <span class="n">_lists</span><span class="p">)</span>
        <span class="n">_maxes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sublist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">_keys</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[:]</span>

    <span class="n">_update</span> <span class="o">=</span> <span class="n">update</span>


    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if `value` is an element of the sorted-key list.</span>

<span class="sd">        ``skl.__contains__(value)`` &lt;==&gt; ``value in skl``</span>

<span class="sd">        Runtime complexity: `O(log(n))`</span>

<span class="sd">        &gt;&gt;&gt; from operator import neg</span>
<span class="sd">        &gt;&gt;&gt; skl = SortedKeyList([1, 2, 3, 4, 5], key=neg)</span>
<span class="sd">        &gt;&gt;&gt; 3 in skl</span>
<span class="sd">        True</span>

<span class="sd">        :param value: search for value in sorted-key list</span>
<span class="sd">        :return: true if `value` in sorted-key list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span>

        <span class="n">len_keys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">)</span>
        <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">len_sublist</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">len_keys</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>


    <span class="k">def</span> <span class="nf">discard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove `value` from sorted-key list if it is a member.</span>

<span class="sd">        If `value` is not a member, do nothing.</span>

<span class="sd">        Runtime complexity: `O(log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; from operator import neg</span>
<span class="sd">        &gt;&gt;&gt; skl = SortedKeyList([5, 4, 3, 2, 1], key=neg)</span>
<span class="sd">        &gt;&gt;&gt; skl.discard(1)</span>
<span class="sd">        &gt;&gt;&gt; skl.discard(0)</span>
<span class="sd">        &gt;&gt;&gt; skl == [5, 4, 3, 2]</span>
<span class="sd">        True</span>

<span class="sd">        :param value: `value` to discard from sorted-key list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">len_keys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">)</span>
        <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">len_sublist</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">len_keys</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>


    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove `value` from sorted-key list; `value` must be a member.</span>

<span class="sd">        If `value` is not a member, raise ValueError.</span>

<span class="sd">        Runtime complexity: `O(log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; from operator import neg</span>
<span class="sd">        &gt;&gt;&gt; skl = SortedKeyList([1, 2, 3, 4, 5], key=neg)</span>
<span class="sd">        &gt;&gt;&gt; skl.remove(5)</span>
<span class="sd">        &gt;&gt;&gt; skl == [4, 3, 2, 1]</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; skl.remove(0)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        ValueError: 0 not in list</span>

<span class="sd">        :param value: `value` to remove from sorted-key list</span>
<span class="sd">        :raises ValueError: if `value` is not in sorted-key list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1"> not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1"> not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">len_keys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">)</span>
        <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1"> not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">len_sublist</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">len_keys</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1"> not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>


    <span class="k">def</span> <span class="nf">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete value at the given `(pos, idx)`.</span>

<span class="sd">        Combines lists that are less than half the load level.</span>

<span class="sd">        Updates the index when the sublist length is more than half the load</span>
<span class="sd">        level. This requires decrementing the nodes in a traversal from the</span>
<span class="sd">        leaf node to the root. For an example traversal see</span>
<span class="sd">        ``SortedList._loc``.</span>

<span class="sd">        :param int pos: lists index</span>
<span class="sd">        :param int idx: sublist index</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
        <span class="n">_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>
        <span class="n">keys_pos</span> <span class="o">=</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
        <span class="n">lists_pos</span> <span class="o">=</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>

        <span class="k">del</span> <span class="n">keys_pos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">lists_pos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">len_keys_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys_pos</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">len_keys_pos</span> <span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">keys_pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">_index</span><span class="p">:</span>
                <span class="n">child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="n">pos</span>
                <span class="k">while</span> <span class="n">child</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">child</span> <span class="o">=</span> <span class="p">(</span><span class="n">child</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
                <span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pos</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">prev</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">_keys</span><span class="p">[</span><span class="n">prev</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
            <span class="n">_lists</span><span class="p">[</span><span class="n">prev</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
            <span class="n">_maxes</span><span class="p">[</span><span class="n">prev</span><span class="p">]</span> <span class="o">=</span> <span class="n">_keys</span><span class="p">[</span><span class="n">prev</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">del</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_index</span><span class="p">[:]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">len_keys_pos</span><span class="p">:</span>
            <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">keys_pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_index</span><span class="p">[:]</span>


    <span class="k">def</span> <span class="nf">irange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minimum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maximum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
               <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an iterator of values between `minimum` and `maximum`.</span>

<span class="sd">        Both `minimum` and `maximum` default to `None` which is automatically</span>
<span class="sd">        inclusive of the beginning and end of the sorted-key list.</span>

<span class="sd">        The argument `inclusive` is a pair of booleans that indicates whether</span>
<span class="sd">        the minimum and maximum ought to be included in the range,</span>
<span class="sd">        respectively. The default is ``(True, True)`` such that the range is</span>
<span class="sd">        inclusive of both minimum and maximum.</span>

<span class="sd">        When `reverse` is `True` the values are yielded from the iterator in</span>
<span class="sd">        reverse order; `reverse` defaults to `False`.</span>

<span class="sd">        &gt;&gt;&gt; from operator import neg</span>
<span class="sd">        &gt;&gt;&gt; skl = SortedKeyList([11, 12, 13, 14, 15], key=neg)</span>
<span class="sd">        &gt;&gt;&gt; it = skl.irange(14.5, 11.5)</span>
<span class="sd">        &gt;&gt;&gt; list(it)</span>
<span class="sd">        [14, 13, 12]</span>

<span class="sd">        :param minimum: minimum value to start iterating</span>
<span class="sd">        :param maximum: maximum value to stop iterating</span>
<span class="sd">        :param inclusive: pair of booleans</span>
<span class="sd">        :param bool reverse: yield values in reverse order</span>
<span class="sd">        :return: iterator</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">min_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">minimum</span><span class="p">)</span> <span class="k">if</span> <span class="n">minimum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">max_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">maximum</span><span class="p">)</span> <span class="k">if</span> <span class="n">maximum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_irange_key</span><span class="p">(</span>
            <span class="n">min_key</span><span class="o">=</span><span class="n">min_key</span><span class="p">,</span> <span class="n">max_key</span><span class="o">=</span><span class="n">max_key</span><span class="p">,</span>
            <span class="n">inclusive</span><span class="o">=</span><span class="n">inclusive</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span>
        <span class="p">)</span>


    <span class="k">def</span> <span class="nf">irange_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
                   <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an iterator of values between `min_key` and `max_key`.</span>

<span class="sd">        Both `min_key` and `max_key` default to `None` which is automatically</span>
<span class="sd">        inclusive of the beginning and end of the sorted-key list.</span>

<span class="sd">        The argument `inclusive` is a pair of booleans that indicates whether</span>
<span class="sd">        the minimum and maximum ought to be included in the range,</span>
<span class="sd">        respectively. The default is ``(True, True)`` such that the range is</span>
<span class="sd">        inclusive of both minimum and maximum.</span>

<span class="sd">        When `reverse` is `True` the values are yielded from the iterator in</span>
<span class="sd">        reverse order; `reverse` defaults to `False`.</span>

<span class="sd">        &gt;&gt;&gt; from operator import neg</span>
<span class="sd">        &gt;&gt;&gt; skl = SortedKeyList([11, 12, 13, 14, 15], key=neg)</span>
<span class="sd">        &gt;&gt;&gt; it = skl.irange_key(-14, -12)</span>
<span class="sd">        &gt;&gt;&gt; list(it)</span>
<span class="sd">        [14, 13, 12]</span>

<span class="sd">        :param min_key: minimum key to start iterating</span>
<span class="sd">        :param max_key: maximum key to stop iterating</span>
<span class="sd">        :param inclusive: pair of booleans</span>
<span class="sd">        :param bool reverse: yield values in reverse order</span>
<span class="sd">        :return: iterator</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>

        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>

        <span class="c1"># Calculate the minimum (pos, idx) pair. By default this location</span>
        <span class="c1"># will be inclusive in our calculation.</span>

        <span class="k">if</span> <span class="n">min_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_pos</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">min_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inclusive</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">min_pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">min_key</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">min_pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>

                <span class="n">min_idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">min_pos</span><span class="p">],</span> <span class="n">min_key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_pos</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">min_key</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">min_pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>

                <span class="n">min_idx</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">min_pos</span><span class="p">],</span> <span class="n">min_key</span><span class="p">)</span>

        <span class="c1"># Calculate the maximum (pos, idx) pair. By default this location</span>
        <span class="c1"># will be exclusive in our calculation.</span>

        <span class="k">if</span> <span class="n">max_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">max_pos</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inclusive</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">max_pos</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">max_key</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">max_pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                    <span class="n">max_pos</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">max_pos</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">max_idx</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">max_pos</span><span class="p">],</span> <span class="n">max_key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">max_key</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">max_pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
                    <span class="n">max_pos</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">max_pos</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">max_idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">max_pos</span><span class="p">],</span> <span class="n">max_key</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_islice</span><span class="p">(</span><span class="n">min_pos</span><span class="p">,</span> <span class="n">min_idx</span><span class="p">,</span> <span class="n">max_pos</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">,</span> <span class="n">reverse</span><span class="p">)</span>

    <span class="n">_irange_key</span> <span class="o">=</span> <span class="n">irange_key</span>


    <span class="k">def</span> <span class="nf">bisect_left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an index to insert `value` in the sorted-key list.</span>

<span class="sd">        If the `value` is already present, the insertion point will be before</span>
<span class="sd">        (to the left of) any existing values.</span>

<span class="sd">        Similar to the `bisect` module in the standard library.</span>

<span class="sd">        Runtime complexity: `O(log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; from operator import neg</span>
<span class="sd">        &gt;&gt;&gt; skl = SortedKeyList([5, 4, 3, 2, 1], key=neg)</span>
<span class="sd">        &gt;&gt;&gt; skl.bisect_left(1)</span>
<span class="sd">        4</span>

<span class="sd">        :param value: insertion index of value in sorted-key list</span>
<span class="sd">        :return: index</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bisect_key_left</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">bisect_right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an index to insert `value` in the sorted-key list.</span>

<span class="sd">        Similar to `bisect_left`, but if `value` is already present, the</span>
<span class="sd">        insertion point will be after (to the right of) any existing values.</span>

<span class="sd">        Similar to the `bisect` module in the standard library.</span>

<span class="sd">        Runtime complexity: `O(log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; from operator import neg</span>
<span class="sd">        &gt;&gt;&gt; skl = SortedList([5, 4, 3, 2, 1], key=neg)</span>
<span class="sd">        &gt;&gt;&gt; skl.bisect_right(1)</span>
<span class="sd">        5</span>

<span class="sd">        :param value: insertion index of value in sorted-key list</span>
<span class="sd">        :return: index</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bisect_key_right</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="n">bisect</span> <span class="o">=</span> <span class="n">bisect_right</span>


    <span class="k">def</span> <span class="nf">bisect_key_left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an index to insert `key` in the sorted-key list.</span>

<span class="sd">        If the `key` is already present, the insertion point will be before (to</span>
<span class="sd">        the left of) any existing keys.</span>

<span class="sd">        Similar to the `bisect` module in the standard library.</span>

<span class="sd">        Runtime complexity: `O(log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; from operator import neg</span>
<span class="sd">        &gt;&gt;&gt; skl = SortedKeyList([5, 4, 3, 2, 1], key=neg)</span>
<span class="sd">        &gt;&gt;&gt; skl.bisect_key_left(-1)</span>
<span class="sd">        4</span>

<span class="sd">        :param key: insertion index of key in sorted-key list</span>
<span class="sd">        :return: index</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="n">_bisect_key_left</span> <span class="o">=</span> <span class="n">bisect_key_left</span>


    <span class="k">def</span> <span class="nf">bisect_key_right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an index to insert `key` in the sorted-key list.</span>

<span class="sd">        Similar to `bisect_key_left`, but if `key` is already present, the</span>
<span class="sd">        insertion point will be after (to the right of) any existing keys.</span>

<span class="sd">        Similar to the `bisect` module in the standard library.</span>

<span class="sd">        Runtime complexity: `O(log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; from operator import neg</span>
<span class="sd">        &gt;&gt;&gt; skl = SortedList([5, 4, 3, 2, 1], key=neg)</span>
<span class="sd">        &gt;&gt;&gt; skl.bisect_key_right(-1)</span>
<span class="sd">        5</span>

<span class="sd">        :param key: insertion index of key in sorted-key list</span>
<span class="sd">        :return: index</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="n">bisect_key</span> <span class="o">=</span> <span class="n">bisect_key_right</span>
    <span class="n">_bisect_key_right</span> <span class="o">=</span> <span class="n">bisect_key_right</span>


    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of occurrences of `value` in the sorted-key list.</span>

<span class="sd">        Runtime complexity: `O(log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; from operator import neg</span>
<span class="sd">        &gt;&gt;&gt; skl = SortedKeyList([4, 4, 4, 4, 3, 3, 3, 2, 2, 1], key=neg)</span>
<span class="sd">        &gt;&gt;&gt; skl.count(2)</span>
<span class="sd">        2</span>

<span class="sd">        :param value: value to count in sorted-key list</span>
<span class="sd">        :return: count</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_maxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">len_keys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">)</span>
        <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">total</span>
            <span class="k">if</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">len_sublist</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">len_keys</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">total</span>
                <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>


    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a shallow copy of the sorted-key list.</span>

<span class="sd">        Runtime complexity: `O(n)`</span>

<span class="sd">        :return: new sorted-key list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">)</span>

    <span class="n">__copy__</span> <span class="o">=</span> <span class="n">copy</span>


    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return first index of value in sorted-key list.</span>

<span class="sd">        Raise ValueError if `value` is not present.</span>

<span class="sd">        Index must be between `start` and `stop` for the `value` to be</span>
<span class="sd">        considered present. The default value, None, for `start` and `stop`</span>
<span class="sd">        indicate the beginning and end of the sorted-key list.</span>

<span class="sd">        Negative indices are supported.</span>

<span class="sd">        Runtime complexity: `O(log(n))` -- approximate.</span>

<span class="sd">        &gt;&gt;&gt; from operator import neg</span>
<span class="sd">        &gt;&gt;&gt; skl = SortedKeyList([5, 4, 3, 2, 1], key=neg)</span>
<span class="sd">        &gt;&gt;&gt; skl.index(2)</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; skl.index(0)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        ValueError: 0 is not in list</span>

<span class="sd">        :param value: value in sorted-key list</span>
<span class="sd">        :param int start: start index (default None, start of sorted-key list)</span>
<span class="sd">        :param int stop: stop index (default None, end of sorted-key list)</span>
<span class="sd">        :return: index of value</span>
<span class="sd">        :raises ValueError: if value is not present</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_len</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">_len</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">_len</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">+=</span> <span class="n">_len</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="n">_len</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">_len</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="n">_maxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_maxes</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maxes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="n">stop</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">_lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">len_keys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">)</span>
        <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">loc</span> <span class="o">&lt;=</span> <span class="n">stop</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">loc</span>
                <span class="k">elif</span> <span class="n">loc</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">len_sublist</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">len_keys</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                <span class="n">len_sublist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1"> is not in list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>


    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return new sorted-key list containing all values in both sequences.</span>

<span class="sd">        ``skl.__add__(other)`` &lt;==&gt; ``skl + other``</span>

<span class="sd">        Values in `other` do not need to be in sorted-key order.</span>

<span class="sd">        Runtime complexity: `O(n*log(n))`</span>

<span class="sd">        &gt;&gt;&gt; from operator import neg</span>
<span class="sd">        &gt;&gt;&gt; skl1 = SortedKeyList([5, 4, 3], key=neg)</span>
<span class="sd">        &gt;&gt;&gt; skl2 = SortedKeyList([2, 1, 0], key=neg)</span>
<span class="sd">        &gt;&gt;&gt; skl1 + skl2</span>
<span class="sd">        SortedKeyList([5, 4, 3, 2, 1, 0], key=&lt;built-in function neg&gt;)</span>

<span class="sd">        :param other: other iterable</span>
<span class="sd">        :return: new sorted-key list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">)</span>

    <span class="fm">__radd__</span> <span class="o">=</span> <span class="fm">__add__</span>


    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return new sorted-key list with `num` shallow copies of values.</span>

<span class="sd">        ``skl.__mul__(num)`` &lt;==&gt; ``skl * num``</span>

<span class="sd">        Runtime complexity: `O(n*log(n))`</span>

<span class="sd">        &gt;&gt;&gt; from operator import neg</span>
<span class="sd">        &gt;&gt;&gt; skl = SortedKeyList([3, 2, 1], key=neg)</span>
<span class="sd">        &gt;&gt;&gt; skl * 2</span>
<span class="sd">        SortedKeyList([3, 3, 2, 2, 1, 1], key=&lt;built-in function neg&gt;)</span>

<span class="sd">        :param int num: count of shallow copies</span>
<span class="sd">        :return: new sorted-key list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">,</span> <span class="p">[])</span> <span class="o">*</span> <span class="n">num</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">iadd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">))</span>


    <span class="nd">@recursive_repr</span><span class="p">()</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return string representation of sorted-key list.</span>

<span class="sd">        ``skl.__repr__()`` &lt;==&gt; ``repr(skl)``</span>

<span class="sd">        :return: string representation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">type_name</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">(</span><span class="si">{1!r}</span><span class="s1">, key=</span><span class="si">{2!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">type_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check invariants of sorted-key list.</span>

<span class="sd">        Runtime complexity: `O(n)`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">&gt;=</span> <span class="mi">4</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>

            <span class="c1"># Check all sublists are sorted.</span>

            <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)):</span>
                    <span class="k">assert</span> <span class="n">sublist</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">sublist</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>

            <span class="c1"># Check beginning/end of sublists are sorted.</span>

            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">)):</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Check _keys matches _key mapped to _lists.</span>

            <span class="k">for</span> <span class="n">val_sublist</span><span class="p">,</span> <span class="n">key_sublist</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">val_sublist</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">key_sublist</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">val_sublist</span><span class="p">,</span> <span class="n">key_sublist</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="n">key</span>

            <span class="c1"># Check _maxes index is the last value of each sublist.</span>

            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">)):</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Check sublist lengths are less than double load-factor.</span>

            <span class="n">double</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">double</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>

            <span class="c1"># Check sublist lengths are greater than half load-factor for all</span>
            <span class="c1"># but the last sublist.</span>

            <span class="n">half</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">half</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>

                <span class="c1"># Check index leaf nodes equal length of sublists.</span>

                <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)):</span>
                    <span class="n">leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="n">pos</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="n">leaf</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>

                <span class="c1"># Check index branch nodes are the sum of their children.</span>

                <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">):</span>
                    <span class="n">child</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">child</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">):</span>
                        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="k">elif</span> <span class="n">child</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">):</span>
                        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">child_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">child</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="k">assert</span> <span class="n">child_sum</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len_index&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len_maxes&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;maxes&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxes</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len_keys&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;keys&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len_lists&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;lists&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">)</span>
            <span class="k">raise</span>


<span class="n">SortedListWithKey</span> <span class="o">=</span> <span class="n">SortedKeyList</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pyStim 1.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">sortedcontainers.sortedlist</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Alexander Tomlinson.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.2.
    </div>
  </body>
</html>